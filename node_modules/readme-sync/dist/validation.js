"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureIndexMdExists = exports.ensureLinksAreValid = exports.ensureUniqueSlugs = exports.ensureFrontMatter = exports.ensureMaxTwoLevels = exports.ensureNoWeirdFiles = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const chalk_1 = require("chalk");
const gray_matter_1 = __importDefault(require("gray-matter"));
const util_1 = require("./util");
const CATEGORY_LEVEL = 0;
const PAGE_LEVEL = 1;
const SUBPAGE_LEVEL = 2;
function walkDocTree(root, cb, level = 0) {
    let pass = true;
    for (const node of fs_1.default.readdirSync(root)) {
        if (node.startsWith('.'))
            continue;
        const fullpath = path_1.default.join(root, node);
        const stat = fs_1.default.lstatSync(fullpath);
        const valid = cb(fullpath, level, stat);
        if (!valid)
            pass = false;
        if (stat.isDirectory()) {
            const validSubtree = walkDocTree(fullpath, cb, level + 1);
            if (!validSubtree)
                pass = false;
        }
    }
    return pass;
}
function ensureNoWeirdFiles(root) {
    return walkDocTree(root, (filepath, _, stat) => {
        if (stat.isFile()) {
            if (filepath.endsWith('.md'))
                return true;
            console.error(`Stray file at ${filepath}. All files are expected to end in .md`);
            return false;
        }
        if (stat.isDirectory())
            return true;
        const type = stat.isFile() ? 'file'
            : stat.isDirectory() ? 'directory'
                : stat.isBlockDevice() ? 'block device'
                    : stat.isCharacterDevice() ? 'character device'
                        : stat.isFIFO() ? 'fifo'
                            : stat.isSocket() ? 'socket'
                                : stat.isSymbolicLink() ? 'symbolic link'
                                    : 'unknown';
        console.error(`Node of type ${type} at ${filepath} not supported`);
        return false;
    });
}
exports.ensureNoWeirdFiles = ensureNoWeirdFiles;
function ensureMaxTwoLevels(root) {
    return walkDocTree(root, (filepath, level, stat) => {
        if (level === CATEGORY_LEVEL && stat.isDirectory())
            return true;
        if (level === PAGE_LEVEL && (stat.isDirectory() || stat.isFile()))
            return true;
        if (level === SUBPAGE_LEVEL && stat.isFile())
            return true;
        console.error(`${(0, chalk_1.redBright)(filepath)} not allowed. Readme only supports 2 levels of pages.`);
        return false;
    });
}
exports.ensureMaxTwoLevels = ensureMaxTwoLevels;
function validateFrontMatter(docPath, content) {
    const frontmatter = (0, gray_matter_1.default)(content);
    const { title, hidden } = frontmatter.data;
    let passed = true;
    for (const key of Object.keys(frontmatter.data)) {
        if (!['title', 'hidden', 'excerpt'].includes(key)) {
            console.log(`Error: ${(0, chalk_1.redBright)(docPath)}: invalid frontmatter key ${key}`);
            passed = false;
        }
    }
    if (title == null || typeof title !== 'string') {
        console.error(`Error: ${(0, chalk_1.redBright)(docPath)}: title missing or invalid`);
        passed = false;
    }
    if (hidden != null && typeof hidden !== 'boolean') {
        console.error(`Error: ${(0, chalk_1.redBright)(docPath)}: hidden must be true or false`);
        passed = false;
    }
    return passed;
}
/** Ensure that all files have valid frontmatter */
function ensureFrontMatter(root) {
    return walkDocTree(root, (filepath, _, stat) => {
        if (stat.isFile())
            return validateFrontMatter(filepath, fs_1.default.readFileSync(filepath));
        return true;
    });
}
exports.ensureFrontMatter = ensureFrontMatter;
function ensureUniqueSlugs(docs) {
    const slugs = {};
    return walkDocTree(docs, (filepath, level, stat) => {
        if (stat.isDirectory())
            return true;
        let parsedPath = path_1.default.parse(filepath);
        if (level === SUBPAGE_LEVEL && parsedPath.base === 'index.md') {
            parsedPath = path_1.default.parse(parsedPath.dir); // use parent slug
        }
        const slug = (0, util_1.slugify)((0, util_1.nameWithoutOrder)(parsedPath.name));
        if (Object.keys(slugs).includes(slug)) {
            console.error(`Error: ${(0, chalk_1.redBright)(filepath)} has the same slug as ${(0, chalk_1.redBright)(slugs[slug])}`);
            return false;
        }
        else {
            slugs[slug] = filepath;
            return true;
        }
    });
}
exports.ensureUniqueSlugs = ensureUniqueSlugs;
function ensureLinksAreValid(docs) {
    const slugs = [];
    const link = /\[(?<text>[^)\n]+)\]\(doc:(?<target>[A-Za-z0-9-]+)(#[A-Za-z0-9-]+)?\)/g;
    // Step 1: Gather all doc slugs
    walkDocTree(docs, (filepath, level, stat) => {
        if (stat.isFile()) {
            if (level == SUBPAGE_LEVEL && path_1.default.basename(filepath) == 'index.md')
                slugs.push((0, util_1.slugify)((0, util_1.nameWithoutOrder)(path_1.default.parse(path_1.default.dirname(filepath)).name)));
            else
                slugs.push((0, util_1.slugify)((0, util_1.nameWithoutOrder)(path_1.default.parse(filepath).name)));
        }
        return true;
    });
    // Step 2: Check that each link points to a valid slug
    return walkDocTree(docs, (filepath, _, stat) => {
        if (stat.isDirectory())
            return true;
        const contents = fs_1.default.readFileSync(filepath).toString();
        let hasBadLink = false;
        for (const match of contents.matchAll(link)) {
            if (!slugs.includes(match.groups.target)) {
                hasBadLink = true;
                console.error(`Broken link ${(0, chalk_1.underline)((0, chalk_1.blueBright)(`[${match.groups.text}](doc:${match.groups.target})`))} in ${(0, chalk_1.green)(filepath)}`);
            }
        }
        return !hasBadLink;
    });
}
exports.ensureLinksAreValid = ensureLinksAreValid;
function ensureIndexMdExists(root) {
    return walkDocTree(root, (filepath, level, stat) => {
        if (stat.isDirectory() && level == PAGE_LEVEL) {
            if (!fs_1.default.readdirSync(filepath).includes('index.md')) {
                console.error(`Error: "${filepath}" has no index.md`);
                return false;
            }
        }
        return true;
    });
}
exports.ensureIndexMdExists = ensureIndexMdExists;
