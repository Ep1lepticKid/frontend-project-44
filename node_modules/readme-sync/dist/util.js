"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderFromName = exports.nameWithoutOrder = exports.slugify = exports.addDocUnderSlug = exports.removeSlugFromTree = exports.findSlugInTree = exports.findSlugInCategory = void 0;
/**
 * Call fn on each element of arr until it returns non-null, then pass
 * that return value back.
 */
function arrayTryEach(arr, fn) {
    for (const elem of arr) {
        const res = fn(elem);
        if (res != null)
            return res;
    }
    return null;
}
/**
 * Return whether a slug was found in a RemoteTreeEntry
 */
function findSlugInCategory(tree, slug) {
    function findInDocs(doc) {
        if (doc.slug === slug)
            return doc;
        else
            return arrayTryEach(doc.children, findInDocs);
    }
    return arrayTryEach(tree.docs, findInDocs);
}
exports.findSlugInCategory = findSlugInCategory;
function findSlugInTree(tree, slug) {
    for (const [, entry] of tree) {
        const found = findSlugInCategory(entry, slug);
        if (found != null)
            return {
                doc: found,
                category: entry,
            };
    }
    return null;
}
exports.findSlugInTree = findSlugInTree;
/**
 * Modify the tree to remove a doc and all of it's children, returning the doc
 */
function removeSlugFromTree(tree, slug) {
    function remove(doc) {
        const index = doc.children.findIndex(doc => doc.slug === slug);
        if (index === -1) {
            return arrayTryEach(doc.children, remove);
        }
        else {
            return doc.children.splice(index, 1)[0];
        }
    }
    const rootIndex = tree.docs.findIndex(doc => doc.slug === slug);
    if (rootIndex !== -1) {
        return tree.docs.splice(rootIndex, 1)[0];
    }
    else {
        return arrayTryEach(tree.docs, remove);
    }
}
exports.removeSlugFromTree = removeSlugFromTree;
/**
 * Insert a doc into the tree under a given slug
 * Returns true if successful
 */
function addDocUnderSlug(tree, newDoc, parent) {
    function add(doc) {
        if (doc.slug === parent) {
            doc.children.push(newDoc);
            return true;
        }
        else {
            return doc.children.some(add);
        }
    }
    if (parent == null) {
        tree.docs.push(newDoc);
        return true;
    }
    else {
        return tree.docs.some(add);
    }
}
exports.addDocUnderSlug = addDocUnderSlug;
function slugify(name) {
    return name.toLowerCase().replace(/[^A-Za-z0-9-]/g, '-').replace(/--+/g, '-');
}
exports.slugify = slugify;
function parseNameWithOrder(name) {
    const match = name.match(/^(\d+)\s*-\s*(.+)/);
    if (match != null)
        return {
            order: parseInt(match[1]),
            name: match[2],
        };
    else
        return {
            order: undefined,
            name,
        };
}
function nameWithoutOrder(name) {
    return parseNameWithOrder(name).name;
}
exports.nameWithoutOrder = nameWithoutOrder;
function orderFromName(name) {
    return parseNameWithOrder(name).order;
}
exports.orderFromName = orderFromName;
