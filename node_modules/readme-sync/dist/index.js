#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const yargs_1 = __importDefault(require("yargs"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const assert_1 = __importDefault(require("assert"));
const readme_1 = require("./generated/readme");
const util_1 = require("./util");
const chalk_1 = require("chalk");
const debug_1 = __importDefault(require("debug"));
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const validation_1 = require("./validation");
const info = (0, debug_1.default)('readme-sync:info');
const verbose = (0, debug_1.default)('readme-sync:verbose');
const argv = yargs_1.default
    .version(false)
    .options({
    'apiKey': { type: 'string', demandOption: true },
    'docs': { type: 'string', demandOption: true },
    'version': { type: 'string', demandOption: true },
    'validateOnly': { type: 'boolean' },
    'category': { type: 'string', array: true },
    'dryRun': { type: 'boolean', default: false },
}).argv;
const client = (0, readme_1.createClient)({
    fetch: async (url, options) => {
        info(`${options.method} ${url}`);
        verbose('body', options.body);
        verbose('headers', options.headers);
        const response = await (0, isomorphic_fetch_1.default)(url, {
            ...options,
            headers: {
                ...options.headers,
                'x-readme-version': argv.version,
                'authorization': `Basic ${Buffer.from(argv.apiKey + ':').toString('base64')}`,
            }
        });
        verbose('response', response);
        return response;
    }
});
async function upsertDoc(remoteTree, categoryName, filepath, parent, options = {}) {
    (0, assert_1.default)(fs_1.default.statSync(filepath).isFile());
    const docFileName = path_1.default.parse(filepath).name;
    const slug = options.slug ?? (0, util_1.slugify)((0, util_1.nameWithoutOrder)(docFileName));
    const existing = (0, util_1.findSlugInTree)(remoteTree, slug);
    const targetCategory = remoteTree.get((0, util_1.slugify)(categoryName));
    const metadata = (0, gray_matter_1.default)(fs_1.default.readFileSync(filepath));
    const form = {
        slug,
        title: metadata.data.title,
        body: metadata.content,
        excerpt: metadata.data.excerpt,
        order: options.order ?? (0, util_1.orderFromName)(docFileName),
        category: targetCategory.category._id,
        parentDoc: parent === null ? null : parent._id,
        hidden: metadata.data.hidden ?? false,
    };
    const destination = `${(0, util_1.slugify)(targetCategory.category.title)}${parent ? ` / ${parent.slug}` : ''} / ${slug}`;
    if (existing !== null) {
        console.log(`\tUpdating ${(0, chalk_1.blueBright)(filepath)} -> ${(0, chalk_1.green)(destination)}`);
        if (argv.dryRun) {
            console.log(`\t${(0, chalk_1.redBright)('DRY RUN')} PUT ${slug}`);
            return {
                _id: 'id',
                slug,
                body: form.body,
                category: targetCategory.category._id,
                hidden: form.hidden,
                order: form.order,
                parentDoc: form.parentDoc,
                project: 'proj',
                title: form.title,
                type: 'type',
                version: '1',
            };
        }
        const doc = await client.docs.putBySlug({ slug, body: form });
        info(`updated - ${doc.status}`);
        verbose(doc.body);
        if (doc.status == 400) {
            console.error(`Error: ${doc.body.error} - ${doc.body.description}`);
            if (doc.body.errors != null)
                console.error(doc.body.errors);
            throw new Error(doc.body.description);
        }
        const removed = (0, util_1.removeSlugFromTree)(existing.category, slug);
        (0, assert_1.default)(removed != null);
        (0, assert_1.default)((0, util_1.addDocUnderSlug)(targetCategory, removed, parent?.slug));
        info(targetCategory);
        return doc.body;
    }
    else {
        console.log(`\tCreating ${(0, chalk_1.blueBright)(filepath)} -> ${(0, chalk_1.green)(destination)}`);
        if (argv.dryRun) {
            console.log(`\t${(0, chalk_1.redBright)('DRY RUN')} POST ${slug}`);
            return {
                _id: 'id',
                slug,
                body: form.body,
                category: targetCategory.category._id,
                hidden: form.hidden,
                order: form.order,
                parentDoc: form.parentDoc,
                project: 'proj',
                title: form.title,
                type: 'type',
                version: '1',
            };
        }
        const doc = await client.docs.post({ body: form });
        info(`created - ${doc.status}`);
        verbose(doc.body);
        if (doc.status == 400) {
            console.error(`Error: ${doc.body.error} - ${doc.body.description}`);
            if (doc.body.errors != null)
                console.error(doc.body.errors);
            throw new Error(doc.body.description);
        }
        if (doc.body.slug !== slug) {
            console.error(doc.body);
            throw new Error('Bug. Existing document not updated.');
        }
        (0, assert_1.default)((0, util_1.addDocUnderSlug)(targetCategory, { slug, children: [] }, parent?.slug));
        info(targetCategory);
        return doc.body;
    }
}
/**
 * Insert and update a doc and its children
 *
 * integration/
 * +- index.md
 * +- setup.md
 * +- config.md
 */
async function upsertDir(remoteTree, categoryName, dirpath) {
    (0, assert_1.default)(fs_1.default.statSync(dirpath).isDirectory());
    const children = fs_1.default.readdirSync(dirpath);
    if (!children.includes('index.md')) {
        console.error(`ERROR: ${dirpath} requires an index.md page`);
        return;
    }
    const parentName = path_1.default.basename(dirpath);
    const parent = await upsertDoc(remoteTree, categoryName, path_1.default.join(dirpath, 'index.md'), null, {
        slug: (0, util_1.slugify)((0, util_1.nameWithoutOrder)(parentName)),
        order: (0, util_1.orderFromName)(parentName),
    });
    for (const child of children) {
        if (child === 'index.md')
            continue;
        await upsertDoc(remoteTree, categoryName, path_1.default.join(dirpath, child), parent);
    }
}
/**
 * Delete remote docs that are not present locally.
 */
async function deleteNotPresent({ docs }) {
    const getSlug = (f) => (0, util_1.slugify)((0, util_1.nameWithoutOrder)(path_1.default.parse(f).name));
    function findLocalBySlug(slug) {
        for (const category of fs_1.default.readdirSync(argv.docs)) {
            for (const page of fs_1.default.readdirSync(`${argv.docs}/${category}`)) {
                const stat = fs_1.default.lstatSync(`${argv.docs}/${category}/${page}`);
                if (getSlug(page) === slug) // category/slug.md or category/slug/index.md
                    return true;
                else if (stat.isDirectory()) {
                    for (const subpage of fs_1.default.readdirSync(`${argv.docs}/${category}/${page}`)) {
                        if (getSlug(subpage) === slug) // category/x/slug.md
                            return true;
                    }
                }
            }
        }
        return false;
    }
    async function deleteIfNotFoundLocally(doc) {
        if (!findLocalBySlug(doc.slug)) {
            console.log(`\tDeleting ${doc.slug} - not found locally`);
            if (argv.dryRun)
                console.log(`\t${(0, chalk_1.redBright)('DRY RUN')} DELETE ${doc.slug}`);
            else
                await client.docs.deleteBySlug({ slug: doc.slug });
        }
    }
    for (const page of docs) {
        for (const subpage of page.children)
            await deleteIfNotFoundLocally(subpage);
        await deleteIfNotFoundLocally(page);
    }
}
/**
 * Insert, update, and delete remote docs.
 *
 * Only two layers of nesting supported
 *
 * category/
 * +- doc1.md
 * +- doc2.md
 * +- group/
 *    +- child.md
 *    +- index.md
 */
async function sync(remoteTree) {
    for (const category of fs_1.default.readdirSync(argv.docs)) {
        if (category.startsWith('.') || !fs_1.default.statSync(path_1.default.join(argv.docs, category)).isDirectory())
            continue;
        if (argv.category != null && !argv.category.includes((0, util_1.slugify)(category))) {
            console.log(`Skipping ${(0, chalk_1.redBright)(category)}`);
            continue;
        }
        console.log(category);
        const categoryPath = path_1.default.join(argv.docs, category);
        for (const doc of fs_1.default.readdirSync(categoryPath)) {
            const docPath = path_1.default.join(categoryPath, doc);
            if (doc.startsWith('.')) {
                continue;
            }
            else if (doc.endsWith('.md')) {
                await upsertDoc(remoteTree, category, docPath, null);
            }
            else {
                await upsertDir(remoteTree, category, path_1.default.join(argv.docs, category, doc));
            }
        }
        await deleteNotPresent(remoteTree.get((0, util_1.slugify)(category)));
    }
}
async function main() {
    const remoteTree = new Map();
    let errored = false;
    const checks = [
        validation_1.ensureNoWeirdFiles,
        validation_1.ensureMaxTwoLevels,
        validation_1.ensureIndexMdExists,
        validation_1.ensureUniqueSlugs,
        validation_1.ensureFrontMatter,
        validation_1.ensureLinksAreValid,
    ];
    for (const check of checks)
        if (!check(argv.docs))
            process.exit(1);
    console.log('Docs look good');
    if (argv.validateOnly) {
        return;
    }
    // we need to fetch the categories from local dir names because there is no API to get this from readme.com
    // TODO: use /api/v1/categories
    console.log('Fetching categories');
    for (const localCategoryName of fs_1.default.readdirSync(argv.docs)) {
        if (localCategoryName.startsWith('.') || !fs_1.default.statSync(path_1.default.join(argv.docs, localCategoryName)).isDirectory())
            continue;
        const slug = (0, util_1.slugify)(localCategoryName);
        const [remoteCategory, remoteDocs] = await Promise.all([
            client.categories.getBySlug({ slug }),
            client.categories.getDocsBySlug({ slug }),
        ]);
        if (remoteCategory.status == 200 && remoteDocs.status == 200) {
            (0, assert_1.default)(remoteCategory.body.slug === slug);
            console.log(`Got ${(0, chalk_1.yellow)(localCategoryName)}`);
            remoteTree.set(slug, {
                category: remoteCategory.body,
                docs: remoteDocs.body.map(parent => ({
                    slug: parent.slug,
                    children: parent.children.map(child => ({
                        slug: child.slug,
                        children: [],
                    })),
                })),
            });
        }
        else {
            if (remoteCategory.status == 404) {
                console.error(`I cannot create categories yet. Please manually create the category ${localCategoryName} (slug ${slug}) in Readme.`);
                errored = true;
            }
            else {
                console.error(remoteCategory);
                console.error(remoteDocs);
                throw new Error('something happened');
            }
        }
    }
    if (errored)
        process.exit(1);
    info(remoteTree);
    await sync(remoteTree);
}
main().catch((err) => {
    console.error(err);
    process.exit(1);
});
