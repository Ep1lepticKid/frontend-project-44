"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClient = exports.DocsResource = exports.CategoriesResource = exports.$Resource = exports.$HttpClient = exports.stripQuery = exports.parseHeaders = exports.parseJson = exports.isResponseJson = exports.isResponseEmpty = void 0;
const url = __importStar(require("url"));
function isResponseEmpty(response) {
    const contentLength = response.headers.get('Content-Length');
    return contentLength != null && Number.parseInt(contentLength, 10) === 0;
}
exports.isResponseEmpty = isResponseEmpty;
function isResponseJson(response) {
    const contentType = response.headers.get('Content-Type');
    return contentType != null && contentType.indexOf('json') >= 0;
}
exports.isResponseJson = isResponseJson;
function parseJson(response) {
    return !isResponseEmpty(response) && isResponseJson(response) ? response.json() : Promise.resolve();
}
exports.parseJson = parseJson;
function parseHeaders(response) {
    const headers = {};
    response.headers.forEach((value, key) => {
        headers[key.toLowerCase()] = value;
    });
    return headers;
}
exports.parseHeaders = parseHeaders;
function stripQuery(query = {}) {
    const initialValue = {};
    return Object.keys(query).reduce((previousValue, key) => {
        const value = query[key];
        if (value != null)
            previousValue[key] = value;
        return previousValue;
    }, initialValue);
}
exports.stripQuery = stripQuery;
class $HttpClient {
    constructor(options) {
        this.options = options;
    }
    request(options) {
        const finalUrl = url.format({
            hostname: 'dash.readme.io',
            pathname: '/api/v1' + options.endpoint,
            protocol: 'https:',
            query: stripQuery(options.query),
        });
        const finalHeaders = {
            accept: 'application/json',
            'content-type': 'application/json',
            ...options.headers,
        };
        const request = {
            body: options.body,
            headers: finalHeaders,
            method: options.method,
            url: finalUrl,
        };
        return this.options.fetch(request.url, {
            body: JSON.stringify(request.body),
            headers: request.headers,
            method: request.method,
        }).then((response) => {
            return parseJson(response).then((json) => {
                return {
                    body: json,
                    headers: parseHeaders(response),
                    ok: response.ok,
                    request,
                    status: response.status,
                    statusText: response.statusText,
                };
            });
        });
    }
}
exports.$HttpClient = $HttpClient;
class $Resource {
    constructor(options) {
        this.client = new $HttpClient(options);
    }
}
exports.$Resource = $Resource;
class CategoriesResource extends $Resource {
    getBySlug(params) {
        return this.client.request({
            endpoint: `/categories/${encodeURIComponent(params.slug)}`,
            headers: params.headers,
            method: 'GET',
        });
    }
    getDocsBySlug(params) {
        return this.client.request({
            endpoint: `/categories/${encodeURIComponent(params.slug)}/docs`,
            headers: params.headers,
            method: 'GET',
        });
    }
}
exports.CategoriesResource = CategoriesResource;
class DocsResource extends $Resource {
    post(params) {
        return this.client.request({
            body: params.body,
            endpoint: '/docs',
            headers: params.headers,
            method: 'POST',
        });
    }
    putBySlug(params) {
        return this.client.request({
            body: params.body,
            endpoint: `/docs/${encodeURIComponent(params.slug)}`,
            headers: params.headers,
            method: 'PUT',
        });
    }
    deleteBySlug(params) {
        return this.client.request({
            endpoint: `/docs/${encodeURIComponent(params.slug)}`,
            headers: params.headers,
            method: 'DELETE',
        });
    }
}
exports.DocsResource = DocsResource;
function createClient(options) {
    return {
        categories: new CategoriesResource(options),
        docs: new DocsResource(options),
    };
}
exports.createClient = createClient;
